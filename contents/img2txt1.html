<!DOCTYPE html>
<html>
    <head>
        <title>Image Captioning (Show, Attend and Tell)</title>
        <meta name="description" content="Image captioning 모델 중 하나인 show, attend and tell 논문에서 구현한 모델을 설명합니다.">
        <meta charset="utf-8">
        <link rel="stylesheet" href="init/index.css">
        <link rel="stylesheet" href="init/contents.css">
        <link rel="stylesheet" href="init/index_img/icons/css/fontello.css">

        <link rel="preconnect" href="https://fonts.googleapis.com"> 
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
        <link href="https://fonts.googleapis.com/css2?family=Dongle:wght@300&display=swap" rel="stylesheet">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR&display=swap" rel="stylesheet">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Gowun+Batang&display=swap" rel="stylesheet">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic&display=swap" rel="stylesheet">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script src="init/index.js"></script>
        <script src="init/jquery.pjax.js"></script>
        
        <meta name="viewport" content="width=device-width, initial-scale=0.8, max-width=1">

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-219110982-1"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-219110982-1');
        </script>
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7745178886614102"
        crossorigin="anonymous"></script>

        <meta property="og:url" content="https://ljm565.github.io/contents/img2txt1.html" />
        <meta property="og:title" content="Image Captioning (Show, Attend and Tell)" />
        <meta property="og:type" content="website">
        <meta property="og:description" content="Image captioning 모델 중 하나인 show, attend and tell 논문에서 구현한 모델을 설명합니다." />
        <meta property="og:image" content="https://lh3.googleusercontent.com/fife/AMPSemd36vRScVexuNq3szlyyRrKHhGKmgT65z91fnYc0N6coxDkEvKT4kkiHIXSDh9tlbuM7GVNEfvJEHzXBBdda1leKzlzP16oqNpVYVYAOKKXWyh_MhwWma2pduZiRdsq7qpPqakgOmGSrZmR1oTf_hH6BE9HBRkaRu2q6QOPzhs0sNQYEd9r3F3lNe8zSahfxbRAFP1Tag-1J9N-3MrFff_Xt9p9tHk1gA3jUyr0Zlen0NCUgfepwBsvV5HQURJcljqc9BNqGA1UPdZ1URwP2wHqMplEiuMxWv2xbgHdigftZfN91qnaov7rQkvff4pCu4Njj1CnfdXILl_6yS-uADThICFIuzaiKyXBvXtRjcOZxJ3hGQGMG-nQkIgV9LBs-QRwqflZ5Qae24h4i2LPjUChpr5mx9vdwu3VVfO-wOerHG4A6X6cybdyM9MbRUxdgOEa1reLenGxAyJM34yeq2xC62l3aB5I1qTDYXt6B69-HzSdb6EufYsSBdxlwHYTlr9fiUt5hMB5ZRxuOp18E1gO-Xd7_T6FpuE0VaqMdVPEe9T5yLqTsY-wDtm5goxEIQDPeGrK5RbSo7odofdMhXCjGecby9TZemx3464i_0pRSGBNmXY9aZQTQ2oLtNdcpJsA266PY036Fakvat4b3nYExlPTGpe2Q2vnh0iCu2ojlzpKX6-wE0qi9WNKEGDN1Gs5ws8JO2G7F1Utbh4fFJ5i51v-u-yuNIn-WmXVhvClcSfIsctUI9eBzCmPg8NvtL0xqU-_jpAufGu-hmaISVNPexfqVLO-2XiOcXNyhhq4bbCesDUJcj6nNAOktslauxSDbCW38hVr2TC7UCAVpTvbW4sHiN1SbA0MbyLAQU9M1NF7qnZyj39a8XRy7cZ70FS7QMqLCOTCYEYj_Cybbnn-H6W_QughDnNMi-16z_F_qkJVXuSipYJyFN-Xy-ALCp6TtBxHuIfbGfOrXOF_VMcX-TDkfV-HMZs4g493pzgNyn_tTyvNHw5vQo5YzZdWZI9aX93sMf-bu7NaKOO_uyBag0CSzPsYSCUIRwBJXqJpwlgqhaFw_pAIsQpJkI8ovMXwlimyJfClLZpQQM6Jxu2l_ZtKuz9hPkFL5l-pGieGBV9_ZWQARADCT-vo9k2L3XB8oOP9zLa7_MtRg-SWOPtU_b3gVMy27hjk0AqgKGdUBVdillqdQMIq5DzUx4TbNo7zbxhlhzbPvTbBKAbbsoH-Wm-UxpXy7-huOdTDWdrUc65NlO7rpfDijc0GECVFeO8PLXOoPOmaJcAT9p9z3XwzkzNhk9ilI5Sg0YhzRmfykfn3YkPHbhHWxycStkk44ZQm647sbSTlj4H5bPoDtI4FR3xB8lmiGC-8cW8oyqGx54zgKDyYaOkqb7tZCg1vUXId0wGeyjo8wKQmq4AZzxbI6ycSMDnVSOt600-z2QYEMlAT4whgWshUJqH6DJbuwdGAY-1HcBUqIsbYetdBK_Q" />
    </head>   
    <body>
        <div id="modeButton">
            <button type="button" value="dark" onclick="darkMode(this)" onmouseover="hoveringOn(this)" onmouseout="hoveringOff(this)">
                <div class="modeImg"><img id="modeImg" src="init/index_img/moon_off.png"></div>
                <div id="modeState">다크 모드로 보기</div>
            </button>
        </div>

        <div id="container" onclick="reload();">
            <article>
                <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
                <script>
                    initMathJax();
                </script>
                <div id="mainHeadWrapper">
                    <div id="mainHead">
                        <h1 class="contentHead">딥러닝 이야기 / Image Captioning / 1. Image Captioning (Show, Attend and Tell)</h1>
                    </div>
                </div>
                
                <div class="title" style="background-image:url(https://lh3.googleusercontent.com/fife/AMPSemd36vRScVexuNq3szlyyRrKHhGKmgT65z91fnYc0N6coxDkEvKT4kkiHIXSDh9tlbuM7GVNEfvJEHzXBBdda1leKzlzP16oqNpVYVYAOKKXWyh_MhwWma2pduZiRdsq7qpPqakgOmGSrZmR1oTf_hH6BE9HBRkaRu2q6QOPzhs0sNQYEd9r3F3lNe8zSahfxbRAFP1Tag-1J9N-3MrFff_Xt9p9tHk1gA3jUyr0Zlen0NCUgfepwBsvV5HQURJcljqc9BNqGA1UPdZ1URwP2wHqMplEiuMxWv2xbgHdigftZfN91qnaov7rQkvff4pCu4Njj1CnfdXILl_6yS-uADThICFIuzaiKyXBvXtRjcOZxJ3hGQGMG-nQkIgV9LBs-QRwqflZ5Qae24h4i2LPjUChpr5mx9vdwu3VVfO-wOerHG4A6X6cybdyM9MbRUxdgOEa1reLenGxAyJM34yeq2xC62l3aB5I1qTDYXt6B69-HzSdb6EufYsSBdxlwHYTlr9fiUt5hMB5ZRxuOp18E1gO-Xd7_T6FpuE0VaqMdVPEe9T5yLqTsY-wDtm5goxEIQDPeGrK5RbSo7odofdMhXCjGecby9TZemx3464i_0pRSGBNmXY9aZQTQ2oLtNdcpJsA266PY036Fakvat4b3nYExlPTGpe2Q2vnh0iCu2ojlzpKX6-wE0qi9WNKEGDN1Gs5ws8JO2G7F1Utbh4fFJ5i51v-u-yuNIn-WmXVhvClcSfIsctUI9eBzCmPg8NvtL0xqU-_jpAufGu-hmaISVNPexfqVLO-2XiOcXNyhhq4bbCesDUJcj6nNAOktslauxSDbCW38hVr2TC7UCAVpTvbW4sHiN1SbA0MbyLAQU9M1NF7qnZyj39a8XRy7cZ70FS7QMqLCOTCYEYj_Cybbnn-H6W_QughDnNMi-16z_F_qkJVXuSipYJyFN-Xy-ALCp6TtBxHuIfbGfOrXOF_VMcX-TDkfV-HMZs4g493pzgNyn_tTyvNHw5vQo5YzZdWZI9aX93sMf-bu7NaKOO_uyBag0CSzPsYSCUIRwBJXqJpwlgqhaFw_pAIsQpJkI8ovMXwlimyJfClLZpQQM6Jxu2l_ZtKuz9hPkFL5l-pGieGBV9_ZWQARADCT-vo9k2L3XB8oOP9zLa7_MtRg-SWOPtU_b3gVMy27hjk0AqgKGdUBVdillqdQMIq5DzUx4TbNo7zbxhlhzbPvTbBKAbbsoH-Wm-UxpXy7-huOdTDWdrUc65NlO7rpfDijc0GECVFeO8PLXOoPOmaJcAT9p9z3XwzkzNhk9ilI5Sg0YhzRmfykfn3YkPHbhHWxycStkk44ZQm647sbSTlj4H5bPoDtI4FR3xB8lmiGC-8cW8oyqGx54zgKDyYaOkqb7tZCg1vUXId0wGeyjo8wKQmq4AZzxbI6ycSMDnVSOt600-z2QYEMlAT4whgWshUJqH6DJbuwdGAY-1HcBUqIsbYetdBK_Q);">
                    <div>
                        <span class="mainTitle">Image Captioning (Show, Attend and Tell)</span>
                        <br><br>
                        <div style="display: table-cell; margin: 0;">
                            <img src="init/index_img/profile.png" style="width: 30px; cursor: pointer;" onclick="pjaxPage('/');">
                        </div>
                        <span class="subTitle" style="display: table-cell; text-align: left; vertical-align: middle; padding-left: 20px; line-height: 125%;">작성자: 여행 초짜<br>작성일: 2022.09.17</span>
                    </div>
                </div>

                <div id="content">
                    <p>
                        시작하기 앞서 틀린 부분이 있을 수 있으니, 틀린 부분이 있다면 지적해주시면 감사하겠습니다.
                        
                        <br><br>이번 글에서는 multimodal learning의 일종인 image captioning 모델에 대해 설명하겠습니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">먼저 multimodal learning은 다른 타입의 데이터를 가지고 학습을 하는 것을 의미합니다.
                        예를 들어 image captioning같은 경우는 이미지와 텍스트, Speech-to-text (STT) 모델같은 경우는 음성, 텍스트를 가지고 학습을 진행하며, 이렇게 다양한 타입의 데이터를 바탕으로 학습을 진행하는 것을 multimodal learning이라고 합니다.</span>
                        즉 modality는 데이터의 타입이라고 생각할 수 있습니다.

                        <br><br><span class="highlight" style="color: rgb(0, 3, 206);">본 글에서는 image captioning을 최초로 시도한 논문인 "Show and Tell: A Neural Image Caption Generator"을 간단히 살펴보고, attention 기법을 도입한 "Show, Attend and Tell: Neural Image Caption Generation with Visual Attention" 논문도 살펴보겠습니다.</span>
                    </p>
                    <div class="link">
                        <a href="https://arxiv.org/pdf/1411.4555.pdf" target="_blank" onmouseover="colorOn(this);" onmouseout="colorOff(this);">Show and Tell: A Neural Image Caption Generator 논문</a>
                    </div><br>
                    <div class="link">
                        <a href="https://arxiv.org/pdf/1502.03044.pdf" target="_blank" onmouseover="colorOn(this);" onmouseout="colorOff(this);">Show, Attend and Tell: Neural Image Caption Generation with Visual Attention 논문</a>
                    </div>
                    <p>
                        <br><br>오늘의 컨텐츠입니다.
                        <ol>
                            <li>Show and Tell</li>
                            <ul><li>모델 구조</li></ul>
                            <li>Show, Attend and Tell</li>
                            <ul>
                                <li>모델 구조</li>
                                <li>Soft Attention</li>
                                <li>Hard Attention</li>
                            </ul>
                        </ol>
                    </p>



                    <h1 class="subHead">Show and Tell</h1>
                    <div class="doubleSubHead">
                        <span style="display: block; text-align: center;">&ldquo;</span>
                        <span>모델 구조</span><br>
                        <span style="display: block; text-align: center; margin-top: 13px;">&rdquo;</span>
                    </div>
                    <p>
                        먼저 show and tell 논문입니다. Image captioning을 위한 딥러닝 모델은 2014년에 이 논문에서 최초로 제안되었습니다.
                        이미지를 텍스트로 변환하는 원리를 대략 떠올려본다면 encoder를 통해 이미지를 representation한 후, 이 결과를 decoder로 넣어 문장을 생성하는 방식이 떠오를 것입니다.
                        너무 당연하게도 위 논문도 encoder-decoder로 구성된 모델이며, encoder는 CNN 기반, decoder는 LSTM 모델로 제작됩니다.

                        <br><br>아래 그림은 실제 이 논문에서 설명하고 있는 모델 구조입니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">Pre-trained CNN 모델을 불러와서 encoder로 사용하고, LSTM decoder를 학습하는 구조입니다.</span>
                        이때 encoder의 feature는 LSTM의 첫 번째 input으로 들어가게 됩니다.
                        그리고 우리가 잘 아는 autoregressive 방식으로 decoder를 학습하는 것입니다.
                        이 모델은 당시에 image captioning 모델 중 state of the art (SOTA)를 달성하게 됩니다.
                    </p>
                    <div class="contentImg">
                        <img src="https://lh3.googleusercontent.com/fife/AMPSeme_WnMy2txmE694zOFkY0oyq_hFlHXFbppG8BFQggQcuw9TEHOCNuL1_Yx6M2_pfHT_1e2fvu862SjTPeTal0yMiPoTy-fh9UFrsztrgecKxXA_YvSnbVbq5yHcvHRtdbu-SCOAyqO_VK9yZ6TnudsIk1TOl44c1Q_qsKlKobW23SPTLAcbjYNFWbRF-zW7A5OS-_afyhpGWPwwXUvu7Kn807tNbF2BErApq5Bc-O746mO3ipWysllht-w1PwGZ8dgHb0gTXv5pOTRLjQBZSpqYFGo_LlHZQqEFN8vVTIdWiIH_3CnzWXbojInYFqOSBHY6XB4nH37VUvgvbAkN0x59Vz3xUjsTdiTF_uEk2O_gts5uYmmbShuYctLg73jbO1my7mjfqma10NXmWLmn_TO7DjjCzJA0EvZPi1ePpiB8RhzP5pIUfxq679ypKlmBRH-sYOp-5SEZgN2FER9EKAATUwGmGZJTK1EGhyO8A-MqWRwNGDEYcDse3Vfw4yZlVSsssjnpMTfAjYai5qhq4gfjgPRyqFGZkjpkIvv-GiHeqsZlYCmmXr_kdsqoeJHS1u5FeBd_yr3TirjmarKpdtLGhPAJkORqdEW1NStQSB4LGYY_RJt1ego7_dLoMbx-um9z1c-toROyVOeWok0Q2iZIFsXB10AzJ7qTk2GHnGvlBCwCvoCuSFH-28EMrUBuPrEgQ-CxIdsInEMvTtPoA9XPfdDWSKOr2dvDtORStkbiXxTZ2X9-ZIw7yWFWeRpoKRnwsMcRGnuvE-o7LimuJgNKunFSqC0SNLJPlZP8hjkCX20TPkwmloL3EAKlsJj_9EyvJiuCxlW-Y1Zopfo5-4hoC2tqDVCKsa_fBU0_u44ZUSD8sBndlBX7-gPihLA4PltXyjyDV5IfT0IUVPcvtA5dtERV3gJ5qQKO67bGf8Jjn7dBYcRlAIcVG6loFoStpTLFBqc63RalYrPFUqYidS2VXisVZNSc8NL6CicRNdVSt_plX5WghWxqb58aw_TSSnuSpjudvXUevecUgR1nHMsGqD8UyAvwdGruE4nt0lyt7Q8BwNMjeV8Aahl9vU8ISLm9DuCBkpBROLvMnGfiMsr6-h5xBZqrrHx0NlrSbTq2mVUNeal1u_DLn7_REW1xT9BEyEcxcZnq4yFuwbM9Uz3PeTiZtCzhKCG_KysR1LJeYXo4BWifwkZBwkGSkWnwweLODubD1BU9qTAdNRvmZdfAkHN2ltgLDunhfthIn1thT5VRfiFQ2IQchzaOcmGtZnEEdtliqUORyjwk_6ghRLWYs2v1idSCVK1Shkqg5ktr6rbUQWIUrnt-rLV5c8N2TJzSuA5cIP8J3SFxrb6ckjnQQyDC472PBw7S7K1gjE0OS3XK9W5cfK6rLiZF2hDlMYnEX2cCXtGS8EU8TBW6cwm5hIKuIgdEYaxodrNC8wQLyFXN8fX50N_OFC-6q_gwcs_L623S9CNA54pWSuuOIYU" style="width: 100%;">
                        <p class="caption">모델 구조, 출처: Show and tell 논문</p>
                    </div>
                    <p>
                        <br>아래 그림은 좀 더 자세한 구조를 보여주는 그림입니다.
                    </p>
                    <div class="contentImg">
                        <img src="https://lh3.googleusercontent.com/fife/AMPSemfAIKg5p3NVr3HXw31uUzcL8JXHmmURNQN6U3Sg70a_2UknHgTrLqR2onxvZfxvg6j7Mev6XmD9w2hsxSx87-6QmhaQX1Powk5lFZGt4IekO82io7DQaUeS-TVWmhPEiykaNSvfF5deDgccR_Vfv_lk2xLzx6PUo5I09D5Jgbhvb67GRV26XNjhDhuRZWB6092sj_MF3gPNZS_CcvPWMtAT59sAt77tgoeJPRtFhxXpBAflb26xOVk2uthQfQ0GfcFTP4DhHim2SVbY2ebr832nprmkwotvJkyjwX6DoZf_WOWZL04hpDAIXJQ2rnpictEuj2k2r8IA--xUGuKERpmJw7USH4y8modx6QiSm-pbN28ny8JRgrqHNpSufZKCovz1U518UESNn5PB6-0YXkTaWE-jOd_7G0PsFFUvAfLrvdGjzXszFgSn2nXnHrSFs-UynpD6fX36mL7Q4TjitiXvraSAABX6FxunEHyFvmIAxyg08HiTRl10IoP4rFjj1upbaMAhAEBjYIdcX1ALTYcvGTO5ZXZEwSJbDnItzs0pokAXD2YXNRXGMnJ0AuQZtvigWE5fgfBCVyserk5TstC-jX88C5y_JWpNIlR7nZ11Bq-UkZ832En8GKEA3AuEbnLB-CpV5RlHXAFIolxpGH_erxoqmW6ltm0zl6vI3y4fOHsY1QGfNmpu96HnmLcVsV_3TpLlhqHoHpcQMn2ltmzcc7lcaHSjwwNMDKVZ793ZhvCK00ir8gS_oibyHEPS10WjJaxNNNFVnLxsbk44niOkVGuqvPrvyuJoJxxooHJ7zymjOVlkK35o0eWoqOioXgvtGBIP9S6XW4lxZrx4pNxFsTTn1Cc_54ie8r07g5hPgOKE8xFah2-BXVgmtUp8bdwTe34oKsftePL_shRB5eRilFXZgzoaIX67dCmBeQVn5YRojydjIwTBXJbbsTOplJPKYKRLzNthTAbh9IGoXGq3WKBr5dSju6GKT3USokluEpahp5spF7BsPT93RK05PpWHMovLTTqD75DgvByA_qeizYR-M6HBq_3EWiv2dkSjljDiKjn1eQ7KDyYI8y1VUMtl-h2O4kS95vwv15GVLY7EeI1B1Pv6vTSDNy-12ubwu2_SeIuxKzWA5cs-p9NoM3LHXO1uJHUmLK3GzGGYjisY5zFUn5xf4t3V6SKnkIarB4hQ2jRsZcT3nuS1HHUqG0nvklMRk3vY4jo8HSkpDfPy8oZH5EtVTZ-YldaCO7P9PPmSgnkiYoB2VieJ99d_EnEe7K6tq2qiree5XP8yHaNp1JBunCrzzew1QqZXmV3-yrZKIYIXSBnk1Vwp8D5lxFmIdsu_uZCBINWJiSpoIEKjoTcI4TuHJvfymfiK4yHsDxSejkLtwh2uh7_XVg4INHSGWaRoAfxmZBqf5OLqfvovra0g8aoYcMfjt0mKzj0K4yqDTxeSzQ9u-CPA7fW0LfESgyac6Sav7Yi-_nvOxv8" style="width: 100%;">
                        <p class="caption">모델 구조, 출처: https://github.com/reyllama/paper-reviews/issues/5</p>
                    </div>
                    


                    <h1 class="subHead">Show, Attend and Tell</h1>
                    <div class="doubleSubHead">
                        <span style="display: block; text-align: center;">&ldquo;</span>
                        <span>모델 구조</span>
                        <span style="display: block; text-align: center; margin-top: 13px;">&rdquo;</span>
                    </div>
                    <p>
                        이제는 show and tell 논문 이후에 attention을 추가하여 나온 show, attend and tell 모델에 대해 알아보겠습니다.
                        이 모델도 위에서 설명한 모델과 동일하게 encoder-decoder 구조이며, encoder와 decoder는 각각 CNN, LSTM 기반의 모델입니다(LSTM layer는 1개만 사용).
                        <span class="highlight" style="color: rgb(0, 3, 206);">세부적인 훈련 방식도 다르긴하지만 가장 큰 차이점은 attention을 이용한 것입니다.</span>
                        기존 text-to-text를 위한 encoder-decoder 구조의 모델에서도 attention을 사용했었습니다(<a onclick="pjaxPage('RNN2.html');"><span class="highlight" style="color: rgb(0, 3, 206);">seq-to-seq 설명 글</span></a>, <a onclick="pjaxPage('RNN4.html');"><span class="highlight" style="color: rgb(0, 3, 206);">encoder-decoder attention 구현 글</span></a>).
                        이러한 attention을 CNN 기반의 encoder를 사용한 모델에 적용한 것입니다.

                        <br><br>아래 그림은 본 논문에서 사용한 구조를 자세하게 보여줍니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">아래 그림은 soft attention에 대한 모델 구조이며, 논문에서 소개한 두 가지의 attention인 soft attention과 hard attention에 대한 설명은 아래에서 하겠습니다.</span>
                        
                        <br><br>이 구조도 attention을 사용하는데, 이전 neural machine translator의 Bahdanau attention의 구조와 동일합니다(<a onclick="pjaxPage('RNN2.html');"><span class="highlight" style="color: rgb(0, 3, 206);">seq-to-seq 설명 글</span></a> 참고).
                        <span class="highlight" style="color: rgb(0, 3, 206);">다만 이전 번역 모델과 다른점은 encoder입니다. RNN 계열의 encoder를 번역 모델을 학습할 때 사용했었는데, 본 연구에서는 ImageNet으로 pre-trained 된 CNN 모델(e.g. VGGnet)을 encoder로 사용합니다.</span>
                        하지만 기존 번역 모델의 encoder output은 (batch x length x hidden)의 크기로 나왔다면, 여기서는 encoder의 output이 이미지를 모델에 태운 결과이기 때문에 (batch x 512 x 14 x 14)의 크기로 나옵니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">하지만 (batch x 512 x 14 x 14) 차원을 permutation 하면 (batch x 196 x 512)로 만들 수 있으며, 이는 기존 번역 모델 encoder의 output 크기인 (batch x length x hidden)과 일맥상 통합니다.
                        왜냐하면 196은 14 x 14의 이미지를 일렬로 펼쳐놓은 것이므로, 이는 sequence length라고 볼 수 있고, 512은 hidden dimension이라고 볼 수 있기 때문입니다.</span>
                        즉 이 모델의 encoder의 결과는 이미지에서 파생되지만, attention을 사용하는 데 전혀 무리가 없습니다.
                    </p>
                    <div class="contentImg">
                        <img src="https://lh3.googleusercontent.com/fife/AMPSemd36vRScVexuNq3szlyyRrKHhGKmgT65z91fnYc0N6coxDkEvKT4kkiHIXSDh9tlbuM7GVNEfvJEHzXBBdda1leKzlzP16oqNpVYVYAOKKXWyh_MhwWma2pduZiRdsq7qpPqakgOmGSrZmR1oTf_hH6BE9HBRkaRu2q6QOPzhs0sNQYEd9r3F3lNe8zSahfxbRAFP1Tag-1J9N-3MrFff_Xt9p9tHk1gA3jUyr0Zlen0NCUgfepwBsvV5HQURJcljqc9BNqGA1UPdZ1URwP2wHqMplEiuMxWv2xbgHdigftZfN91qnaov7rQkvff4pCu4Njj1CnfdXILl_6yS-uADThICFIuzaiKyXBvXtRjcOZxJ3hGQGMG-nQkIgV9LBs-QRwqflZ5Qae24h4i2LPjUChpr5mx9vdwu3VVfO-wOerHG4A6X6cybdyM9MbRUxdgOEa1reLenGxAyJM34yeq2xC62l3aB5I1qTDYXt6B69-HzSdb6EufYsSBdxlwHYTlr9fiUt5hMB5ZRxuOp18E1gO-Xd7_T6FpuE0VaqMdVPEe9T5yLqTsY-wDtm5goxEIQDPeGrK5RbSo7odofdMhXCjGecby9TZemx3464i_0pRSGBNmXY9aZQTQ2oLtNdcpJsA266PY036Fakvat4b3nYExlPTGpe2Q2vnh0iCu2ojlzpKX6-wE0qi9WNKEGDN1Gs5ws8JO2G7F1Utbh4fFJ5i51v-u-yuNIn-WmXVhvClcSfIsctUI9eBzCmPg8NvtL0xqU-_jpAufGu-hmaISVNPexfqVLO-2XiOcXNyhhq4bbCesDUJcj6nNAOktslauxSDbCW38hVr2TC7UCAVpTvbW4sHiN1SbA0MbyLAQU9M1NF7qnZyj39a8XRy7cZ70FS7QMqLCOTCYEYj_Cybbnn-H6W_QughDnNMi-16z_F_qkJVXuSipYJyFN-Xy-ALCp6TtBxHuIfbGfOrXOF_VMcX-TDkfV-HMZs4g493pzgNyn_tTyvNHw5vQo5YzZdWZI9aX93sMf-bu7NaKOO_uyBag0CSzPsYSCUIRwBJXqJpwlgqhaFw_pAIsQpJkI8ovMXwlimyJfClLZpQQM6Jxu2l_ZtKuz9hPkFL5l-pGieGBV9_ZWQARADCT-vo9k2L3XB8oOP9zLa7_MtRg-SWOPtU_b3gVMy27hjk0AqgKGdUBVdillqdQMIq5DzUx4TbNo7zbxhlhzbPvTbBKAbbsoH-Wm-UxpXy7-huOdTDWdrUc65NlO7rpfDijc0GECVFeO8PLXOoPOmaJcAT9p9z3XwzkzNhk9ilI5Sg0YhzRmfykfn3YkPHbhHWxycStkk44ZQm647sbSTlj4H5bPoDtI4FR3xB8lmiGC-8cW8oyqGx54zgKDyYaOkqb7tZCg1vUXId0wGeyjo8wKQmq4AZzxbI6ycSMDnVSOt600-z2QYEMlAT4whgWshUJqH6DJbuwdGAY-1HcBUqIsbYetdBK_Q" style="width: 100%;">
                        <p class="caption">모델 구조(soft attention)</p>
                    </div>
                    <p>
                        <br>참고로 위 그림의 size 중 B는 batch size, 초반 그림의 H는 height, 이후 decoder 부분의 H는 decoder의 hidden dimension을 의미합니다.
                        <ol>
                            <li>Captioning 하고싶은 이미지를 encoder에 넣고 encoder output을 구함.</li>
                            <li>Encoder output을 두 종류의 linear layer를 이용하여 LSTM initial hidden, cell state를 만들어준 후 넣어줌.</li>
                            <li>위의 방법대로 만든 hidden state를 \(beta\) linear layer를 태워서 가중치 값을 구함.</li>
                            <li>Decoder에서 현재 예측 해야하는 step의 이전 step의 hidden state를 가져옴.</li>
                            <li>위의 encoder output은 B x 196 x 512(B x 512 x 14 x 14 변형)의 크기를 가지고 decoder hidden state는 B x 1 x H의 크기를 가지며, <span class="highlight" style="color: rgb(0, 3, 206);">두 개의 데이터가 decder hidden dimension H의 크기를 가지게끔 linear layer를 태움.</span></li>
                            <li>이렇게 나온 두 개의 데이터를 element-wise로 더한 후, hyperbolic tangent (tanh) 함수에 적용.</li>
                            <li><span class="highlight" style="color: rgb(0, 3, 206);">이렇게 나온 데이터에 encoder 데이터 길이별 현재 decoder step에서 중요하게 여기는 점수를 알기 위해서 H x 1의 linear layer를 태워 B x 196 x 1의 score 결과를 구함.</span></li>
                            <li>Score에 softmax 함수를 적용하여 길이 별 score의 합이 1이 되도록 맞춤.</li>
                            <li>이렇게 확률로써 얻어진 score를 encoder output을 그대로 가져와서 행렬곱 수행하여 context vector를 구함.</li>
                            <li>\(beta\) layer를 통해 구해놨던 가중치 값을 context vector에 곱해주어 최종 context vector를 구함.</li>
                            <li>이렇게 나온 context vector를 다음 step의 input과 concatenate하여 모델에 적용.</li>
                        </ol>

                        <br><br>이렇게 attention이 잘 학습이 된다면 decoder의 step별로 특정 단어를 예측하기 위해서 이미지의 적절한 영역에 attention을 하는 것을 확인할 수 있습니다.
                        예를 들어 captioning 할 때 baby를 예측해야 한다면 이미지의 영역 중, 애기가 있는 영역에 attention을 더 하게 되는 방식이죠.
                        
                        <br><br>아래는 실제 논문의 결과입니다. 바로 아래 이미지는 잘 된 attention의 결과를 보여주고, 더 아래 이미지는 틀린 attention의 결과를 보여줍니다.
                    </p>
                    <div class="contentImg">
                        <img src="https://lh3.googleusercontent.com/fife/AMPSemejG3EWXwugzwO5faU27sfoXk6OhIq9ZKLm78BwFmW2ZQu7a6K64DEENT1vQpNfSE_wfDJE6d-MYzPbmiT4CViBbToAB0GHeqXcl20a1AUDIT71JG5igz5fcFR2sT_UE4YdPlL-CU7iXJEKG3mVXcdeym71aqpkshB6ejVl-tYmswQGTWT48v8ikBrepvre6M_ETJjNj7qeOlK_pDubKceNiWJvYbJSLihyCz4KCYSCP8krpM580iUIoH4Vf9VQyC8olIPDCONL0bJ6gjELqDv9HR3OzzSaZmfg0fuPKE9ADTIoz6xtTQDPNz4JQxN24mt9KumzMNI0Kl84DAd1GLF1v43JDZOlP3h_jLLrPC-qxctzso6_1rqf2vbOPV8k9gVz7rYrnyAipycCIgdPiS1I9MVJdovw3E-HvnWdASny2gwAkH4z_SE9itBpFVOFSvWcC-3EpnrIPZ6MXOvsB-nld7Pv5-5DhIpVJjHY0SSafZQbs9FjP6RlW-SuauipJM6eNX6Oc1ClPqF8IH7Jk5FcHNJ0LN2Wc9VSqoz5G6XFQzxumq3NFpsVLuVMe5HurX9gP-B4z6T3f_Ch0btj0-mM65IAHiFLrNtwoOWmfR5_L2ylObZgnKmc5vlj3i8c_zi-ta4jBfysqayQ5eNTsFLfqmVUGiDXHrgzCIabeZEoSZAaownse2eLcWoV5iSqXyMEydEyLLu6Chmh9q9w3_L2bPs61Yn-n2wW1ZpipPr0griwumjeY1g9gHiGdX6Lyn59ZHZYxxnnMrf9JkosxcnBRQhC2khjtWJnG2WjxIP42vHVWqAOdDOUg8dquyTXY_81Fx5ZNlHhyZkYyDd4pBmJb9Z_NL33tJfXnl_bdCB-7n4af7mWfQ-_eRXqsl7CLE7sYPdCNFk2AHyPyIYfvHnMj9i1fmbzwovWrYmD0-DPBa5X4FzdBEwplkvQ6oqE40g9oKJ3KKszv4_FSIDibt2Wz8qRBCzZzii3k-Gzy2RC_wqXQTHie1WkU3zXDJgPBw8Pl6RdijhxB2p8P-Ylm2pPiOwB_hs35QLutSNkdfqASCLjBrsQsFUxKPQl_bqg5BJhXHs84TbPVuOeE8KrW05BMtxAAiYcTlJnQUZg3QDPj9U4uOW9IKz__fLr7nem3MLFwcvGHq9L-kK4v5oK89U0ei0VBzmkX9Ttd8BPL32btXeZNAWwHfpcLeov8f4PczMZg_83eEi6DgvBz2fEIUvWTyD0oPBjan7WpssBC6F0PNuGe0LDXEJmlbwtqj0aOn8yABKa2xzO0KkYWFCYGWnRsy1hb4l8PeCoASWtghRGlo_IaiLSMe8kdaqGfUxwv-39UrAhkdXRfgnuoq4_XJN6cVtMRwQ85Utluc8E-9e5rIC9jkjmdaBILr2ugujREwjCfaqs1fkut4vsh4KPb5UdPqCyYLjwNJOmINt_IJ9uZ8siTRVIFbhVOGwFSPdd090YaBwAvSSxb8Vz9flrGmw" style="width: 100%;">
                        <p class="caption">올바른 Attention 결과, 출처: Show, Attend and Tell 논문</p>
                    </div>
                    <p>
                        <br><span class="highlight" style="color: rgb(0, 3, 206);">아래 예시는 틀리게 예측한 경우이긴 하지만, 이미지의 전체 모습을 대략적으로 잘 파악하고 있다는 것을 보여줍니다.</span>
                    </p>
                    <div class="contentImg">
                        <img src="https://lh3.googleusercontent.com/fife/AMPSemfK5UJs0otrfTAHU3KmVbWUm4DoaymlKu7oaTBNydxxvvLCZYbu-b-dHV8VpeE4QsOHj5N9iGsgYtOU9qQjdXByyPVKVBhE4bnYJsC4OhrA9Ej94NlujgxXaqcg4yl2IYTPkv5rjSKvGoKC9k2gmUWdX_I4yqIrLV4FR-KD-F_ErUyTlTfD7N9IqxAPsUeanFZEt4rMKNw8IfsF4Gdbz7etpGrqOcxvi6hDTb9-7bGHGkzx9sxJpLex-xxSNZDAY-W8frUO_0UZng9D-FpB7hzn7XXFgiRx2ro41YpktxnQVo2gic3naxkRRj16XgzQ3QQwCNn7Vbqp_40or9YOcUc6K3NbLOER6YQeqcirJSamFGwYfNYvZZdWJJSsFcaWS8JlnMAA1-FUPuU2EKGmAzaFpgl6_qgCV2XsrozRjDRJ3JucN86fLV_eOXcBHL6NKqeyLP3Jio-PU7m4nVO5Q1uDokc2KWbMgWi5inM-vjAIjkSX3atSuF0jML_SkPcsuNz2cs_-zz8yg88Au5OmRporZo13sizQL75L7QJ2nXh9JTSUD0KkuzutHEkm-w5F3rSnRDE64UU4GrQCXIfV6Njj55KzvJ0Bfjuj0chJ5gJLrx-NCjDzTNe9KMWDlD_sKAn6ObkchU8Vq6p3-KprAUBY8wb0PcOeQPOX3QASFWHMyCzCqvIth1kxSFw40WV4R2aooitmJN3pZaysLtQPUoVov5EVFnnPMFqyURtAExKzJimjEbKBkT10omqJnLVbToD-GaqSfFy6FKkoxV-K8hl87IlEWZh5arbLWix1JCri7GUvlEn3Sly5uLy8jfFi1rUUXMeduRBZVNm7YP1dajQcWE_q1fo1alMt8ckBQtL2P4l6Qx5FDcIR2w8PoSH98V1kdoA66CEmbXJzz7CY2P54DvaMjxMWDmlx-AhLl30TJKYqNI4E_tv_YHi0sN3naWQJYzTKatvNKeQg8ojFs7lPzg4h84yMDqZJvSPCTp7sDe2zfFqbR3D-gYjO641j-G5jXt6MgoY2mwRgDf6ULo0bXejDRoyVHH8tOyw-WDwOnK6TSoR9FkMnA1HzH0t1p_SfEhKtEL4bZUwi3ZVFZP5nFGMaF9B_-g3IjPb5j6K_Q3bvtoPx3LtGGkW7DUWwJHnqEnHDZTbqBncQsVcLH0IIPEYJ5pQnV8sjxPkgFNid_ZBL8jPaWre2SMcz5PFlRlu9uBNf82iVwCiAmtR_Sl1xxfeL2Yo3C-VaQjmX8xqxfYKzuO2VsL69gJ7TeW9s9Lq3QvYuM6JRT4WtkeW1TSqaIga0O_j-JkMA0Vp4sUR-YWeJLu0jLYoJafGiTtm4YK7WNrRtNMB9omzgQqlGOwiXJtWJ_BsZojygNxzs-bQKk4rSOS1lG8C2D1J3vkBxibH5lzSgNxjvcRBAtLEL8ByYDiJs05_lZTSMKDgpvQAMBpjXyppElc0g1Ak7cntNhbcxfFykF1HW1A3SdHygwRI" style="width: 100%;">
                        <p class="caption">틀린 Attention 결과, 출처: Show, Attend and Tell 논문</p>
                    </div>



                    <div class="doubleSubHead">
                        <span style="display: block; text-align: center; margin-top: 150px;">&ldquo;</span>
                        <span>Soft Attention</span><br>
                        <span style="display: block; text-align: center; margin-top: 13px;">&rdquo;</span>
                    </div>
                    <p>
                        <br>Soft attention은 위의 결과 이미지처럼, 실제 이미지 픽셀별로 softmax를 통해 모델이 어떤 픽셀에 얼마나 집중하고 있는지 계산하는 방식입니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">이러한 방식은 당연히 미분이 가능하며 gradient backpropagation (기울기 역전파)를 통해 학습이 가능합니다.</span>
                        따라서 soft attention을 사용할 경우 end-to-end로 학습이 가능하며, 우리가 흔히 사용하는 backpropagation으로 학습이 가능한 것이지요.
                        이러한 경우 사용하는 loss function을 살펴보겠습니다.

                        <br><br><br><br><span style="font-size: 20px;"><b>Negative Log-likelihood Loss</b></span>
                        <br>Image captioning task는 당연히 들어오는 이미지에 대해 캡션을 다는 모델이기 때문에, decoder의 결과와 실제 target의 캡션과 loss를 계산합니다.
                        실제 이미지를 \(x\), 캡션을 \(y\)라고 했을 때, loss 식은 아래와 같이 쓸 수 있습니다.
                    </p>
                    <div class="equation">
                        \[-log(P(y|x))\]
                    </div>
                    <p>
                        <br>즉 위의 식은 들어온 이미지 \(x\)에 대해서 ground truth 캡션 \(y\)의 우도를 최대화하는 maximum likelihood estimation (최대 우도 추정)을 하는 것입니다.
                        논문에서는 위의 loss 말고도 regularization loss를 추가합니다.

                        <br><br><br><br><span style="font-size: 20px;"><b>Regularization Loss</b></span>
                        <br>위에서 사용한 attention은 하나의 step마다 이미지로 가서 attention을 합니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">예를 들어 t step에 진행된 196(14 x 14)개의 픽셀의 attention score를 \(\alpha_{t,1}, ..., \alpha_{t,196}\)이라고 가정해보겠습니다.
                        이때 196개의 score의 합은 softmax를 통해 나온 결과이므로 그 합이 1이 됩니다.</span>
                    </p>
                    <div class="equation">
                        \[\sum_{i=1}^{196}{\alpha_{t,i}}=1\]
                    </div>
                    <p>
                        <br>하지만 regularization loss는 각 픽셀별 attention score가 1이 되도록 하는 것과 비슷하게, 각각의 픽셀의 time step별 attention score 합이 1이 되도록 loss를 추가해줍니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">예를 들어 캡션 길이가 32라면, 32번의 decoding step이 있고, 각각의 step마다 attention 결과가 있을 것입니다.
                        이때 \(\alpha_{1,i} + \alpha_{2,i} + ... + \alpha_{32,i}=1\)이 되도록 규제를 한다는 것이지요.</span>
                        어떻게 보면 위의 수식과 비슷하지만 1로 만드는 방향이 다른 것이지요.
                    </p>
                    <div class="equation">
                        \[\sum_{t=1}^{32}{\alpha_{t,i}}=1\]
                    </div>
                    <p>
                        <br>하지만 여기서 의문이 듭니다. 각 step마다 전체 픽셀별 attention score는 softmax를 통해 그 합이 1인데, 합이 1인 attention score들을 step마다 모아서 하나의 픽셀을 선택하여 step별로 합을 다 했을 때 이론적으로 1이 나올 수 있을까요?
                        <br><br><span class="highlight" style="color: rgb(0, 3, 206);">아래 그림에서 빨간 화살표는 attention score를 계산했을 때 softmax를 사용하였기에 무조건 모든 attention score 합이 1이 나옵니다.
                        하지만 규제하고 있는 내용은 파란색 화살표처럼 각 픽셀별로 모든 step의 score 합이 1이 나와야한다는 내용인데, 이 가정에 따르면 모든 attention score는 196이 나와야겠지요.
                        하지만 실제 합은 32이고, 규제하고 있는 내용은 196이 나와야하는데 time step이 196인 특별한 상황 빼고는 이론적으로 불가능합니다.</span>
                    </p>
                    <div class="contentImg">
                        <img src="https://lh3.googleusercontent.com/fife/AMPSemfySaEMuuKYk7DP_A7QqBCOj5KPQNwgsW2lqLECr0pU53ToRI2ntsP4CwhQ_2G_1CFLtczVMtUWV5BydL8P-aECgz_K2ZBpAmKAdyUZxHC7sJNUykyjtFNZEweWaC_9GW1S6ialzwPO1OtMZ2ABaR7B9qmb72Y37a_U88jvx0CmrB3YAOaji7mO1zDhluKXC4Pl0fHiJ7Xg8RsOe7oQNo0xknPdTyIm7jhdJIYFvdNrjOMAG5SLraepOqD8tIeifu_1LxnMRPA7F7Et2jE3M-nSJ7lKXmpS9UP6qbTUhQvpn26QFfl_WPQY5Qwd0EzL-dg35CvYjBn3Lal-57rnac4HgWTJpPI19nDlDspDUK3Vttk6jzqhYrcwNNX-xjGMfaOyu3htJZTbAo2sGLUgfoX6QjU_fWArjNzPZb7olIaBjJin8DPXkU2hRV19YVXjqk5oeNT6llGxD2UZ4GGGyePJkuMl5cRrPdqaNCf416P38gbl2bLCA3ikd9KjwL1_BBEwpYev3B4wqbR-YLjiHpqa7gLxfjXicM_itd6mg75geV96uyT1gth_-nYglCJ9R2VYOQHQz-w59wnB93271n8-3NHZx7VkShMErxwHYAASmvnChy8EZOCI7hw7usogQBpGYcVcAZpnHXuiSKBd4orTmxnQz5KhhVPE9T8ekRCofeZ8yFy4tF_WcZD3yRutEKMsqvsrMuHsdJPvugJUb7CEC8bZOJwH9Ud4clVrzf5TyJJ-5q9hD8mPZS0tECIsXdlRWnxJx8bBhJzlJ47J9nUBm-QEEoI3VeYZDjJmlzlKaMVw09M9d9RtrxiKOCKd2pN735PRSGysSaH1CiS8V3VbEfHfkoQ9iQpk--MFk7MqhhrM33jjQ39FLxRgLC-8Fo4VURqK1hU0dvaxluAJx1SbRiKUGCBYcgQTYr-2wFj7XfLBKsX6jhmB0dkMBTvGxG8RcATtm85HFyIDGwuCbuqtGCt6k5FFBAJTXmjwl8QIMLCBLRQscfhS8A9EJ_15u0VT2tsp7qr2yChIzzyE0OZusL9j7TDm8_IhA24uHRBG-0VluEuswAWQa9l6aAdMZlxMsbMGN7_bUwLOhObHCH50PGr-v7uuJG1kYWeQ8_A9Bb2fvoapSCx_Cdn7kdziRNPo_8FlrnVfXaCB-D0ZFrSKh07hdzoMdeWgH25T1WEU46_-zA8IMdffT357x5hVxNRqQM80XAE5_OBSb_hUPB9BFiu_rCnivKiUDNf5bts9YTM-R-wZ0IIsTHlIJh2_gCiOLjLvFaMzIyFsasRmxA_kyvt5TCnPKmDKs8x4ytwZ8jnlXCKxMLYAJ--Q01-UIr4bh--ave_9CUi8iqhB_nKdFfiMRqJxU1X-q-VkQvI0itEvORX4xaZl6k8-qZzZsfw-4Tclv_Oxyh0O5wADOdgZGZXItKAxgHgpAkbhvbhKj2tBImHElQdS5mfXJe3DJqDSe8_hlu4e1rSQy7hZpNA" style="width: 100%;">
                        <p class="caption">모든 time step의 attention</p>
                    </div>
                    <p>
                        <br>따라서 실제로는 모든 time step의 각 픽셀의 score 합이 1이 될 수는 없지만 그 방향으로 학습이 되도록 "규제"하는 것이지요.
                        <span class="highlight" style="color: rgb(0, 3, 206);">논문의 저자는 이 규제가 캡션 생성 과정에서 각 이미지의 모든 영역에 골고루 집중할 수 있도록 도와주는 역할을 할 수 있다고 주장합니다.</span>
                        즉 이 방법을 통해 모든 픽셀이 캡션을 생성하는 데 중요한 기여를 할 수 있도록 유도하는 것이지요. 그리고 전체 time-step 동안 모든 이미지의 부분을 똑같은 score로 집중하는 것도 방지할 수 있습니다.
                        최종적으로 regularization loss는 아래와 같이 나타낼 수 있습니다.
                    </p>
                    <div class="equation">
                        \[\lambda\sum_{i}^{P}{(1-\sum_{t}^{T}{\alpha_{t,i}})^2}\]
                        \[\lambda:\,regularization\,constant,\,P:\,전체\,픽셀\,수,\,T:\,전체\,time\,step\]
                    </div>
                    <p>
                        <br>즉 위 식을 이때까지 들어왔던 예시를 통해 설명하자면, P: 196, T: 32가 되는 것이지요.
                        그리고 우리는 기존 \(\sum_{i=1}^{P}{\alpha_{t,i}}=1\)만 사용하는 것이 아니라 이제 규제 term을 추가하여 \(\sum_{t=1}^{T}{\alpha_{t,i}}=1\)까지 고려하기 때문에 저자는 이를 doubly stochastic attention이라고 부릅니다.
                        따라서 최종 loss는 아래처럼 쓸 수 있습니다.
                    </p>
                    <div class="equation">
                        \[Loss=-log(P(y|x)) + \lambda\sum_{i}^{P}{(1-\sum_{t}^{T}{\alpha_{t,i}})^2}\]
                    </div>


                    




                    <div class="doubleSubHead">
                        <span style="display: block; text-align: center; margin-top: 150px;">&ldquo;</span>
                        <span>Hard Attention</span><br>
                        <span style="display: block; text-align: center; margin-top: 13px;">&rdquo;</span>
                    </div>
                    <p>
                        <span style="font-size: 20px;"><b>Hard Attention</b></span>
                        <br>Hard attention은 각 픽셀별로 얼마나 집중하고 있는지 계산하는 방식이 아닙니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">즉 attention score를 직접 계산하지 않고 확률적 sampling을 통해 영역을 선택하는 방식입니다.
                        즉 soft attention은 각 픽셀 196개의 attention score의 합이 1이였지만, hard attention은 하나의 픽셀만 1의 값을 가지고 나머지는 0의 값을 가집니다.</span>
                        즉 one-hot encoding의 결과가 나오는 것입니다.

                        <br><br>좀 더 수식적으로 접근해보겠습니다.
                        먼저 \(a\)는 이미지가 encoding 된 feature, 즉 B x 2048 x 196의 결과라고 하겠습니다.
                        그리고 \(\alpha_{t,i}\)는 t-step의 각 픽셀에 대한 attention score라고 가정해보겠습니다. 이 score는 soft attention에서 softmax로 구한 픽셀별 attention score입니다.
                        즉 \(\alpha_{t,1} + ... + \alpha_{t,i}=1\)이 된다는 뜻입니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">마지막으로 \(s_{t,i}\)가 t-step의 i(위 예시에서는 최대 196)번째 픽셀에 대해 one-hot encoding으로 나타낸 값이라고 하겠습니다. 즉 \(s_{t,i}\)는 0, 1 중 하나의 값이고, 하나의 값만 1이 될 것입니다.
                        그리고 모든 \(s_{t,i}\) 대해 동일한 확률로 1을 줄 순 없겠죠. 그렇다면 \(s_{t,i}\)가 1이 될 확률은 어떻게 구할까요?  바로 이 확률 값을 soft attention에서는 score로 사용했던 \(\alpha_{t,i}\)가 됩니다.</span>
                        그리고 \(s_{t,i}\)를 아래와 같이 나타낼 수 있습니다.
                    </p>
                    <div class="equation">
                        \[P(s_{t,i}=1|s_{j &lt; t},a)=\alpha_{t,i}\]
                    </div>
                    <p>
                        <br>위 식에서 '\(j&lt;t\)'라고 적은 이유는 이전 step들을 고려하여 나온 hidden state를 attention에 사용하기 때문입니다. 그리고 attention을 할 때 \(a\)도 사용 되기때문에 조건부 확률에 \(a\)가 있는 것입니다.
                        예를 들어 '개가 잔디 위에서 뒹굴고 있습니다'라는 캡션을 생성하기 위해서 현재 step이 '잔디'를 예측해야한다면, hard attention을 위해 잔디에 해당하는 픽셀의 \(\alpha_{t,i}\)(1이 될 확률)가 높을 것이고, 반면에 '개'에 해당하는 픽셀의 \(\alpha_{t,i}\)(1이 될 확률)가 낮을 것입니다.

                        <br><br>우리는 일상생활에서 날씨 확률을 계산할 수 있습니다. 
                        예를 들어 오늘이 맑은 날이었을 때, 내일이 <span class="highlight" style="color: rgb(0, 3, 206);">맑을 확률: 0.5, 비 확률: 0.2, 후보 C 눈 확률: 0.2, 태풍 확률: 0.1</span> 이런식으로 나타낼 수 있습니다.
                        <br><br>위의 \(s_{t,i}\)도 동일한 맥락입니다. 
                        <span class="highlight" style="color: rgb(0, 3, 206);">\(s_{t,1}\)가 1이 될 확률: 0.4, \(s_{t,2}\)가 1이 될 확률: 0.05, ... , \(s_{t,196}\)이 1이 될 확률: 0.1</span> 이런식인 것입니다. 이때 이 확률이 \(\alpha_{t,i}\)가 되는 것이고요.
                        즉 \(s_{t,i}\)의 확률은 일상생활에서 볼 수 있는 multinomial distribution (다항 분포)와 그 모습이 비슷합니다. 하지만 이 확률의 숨은 의미는 1이 될 확률이기 때문에, 즉 1개의 값만 1이 될 수 있기 때문에 <span class="highlight" style="color: rgb(0, 3, 206);">multinoulli distribution이라고 볼 수 있습니다.</span>
                        
                        <br><br>이렇게 구한 \(s_{t,i}\)는 특정 1개의 값만 1이 되고 나머지는 다 0으로 이루어져있습니다. 이렇게 구한 \(s_{t,i}\)를 \(a\)와 곱하면 아래와 같이 쓸 수 있습니다.
                    </p>
                    <div class="equation">
                        \[\widehat z_t = \sum_{i}{s_{t,i}a_{i}}\]
                    </div>
                    <p>
                        <br>이렇게 구한 \(\widehat z_t\)를 attention의 결과로 사용하는 것입니다.
                        즉 soft attention과의 차이는, soft attention은 \(\alpha_{t,i}\)를 그대로 사용했다면, hard attention은 \(\alpha_{t,i}\)를 바탕으로 하나의 값만 1로 바꿔줘서 사용했다는 점입니다.

                        <br><br>이제 loss function을 생각해보겠습니다.
                        우리는 이미지 feature \(a\)에 대해 캡션 \(y\)의 log likelihood를 최대화 하면 됩니다. 그리고 이 log likelihood 식은 위에서 구한 \(s_{t,i}\)를 이용하여 아래처럼 나타낼 수 있습니다.
                    </p>
                    <div class="equation">
                        \[\log{p(y|a)}=\log{\sum_{s}{p(s|a)p(y|s,a)}} \geq \sum_{s}{p(s|a)\log{p(y|s,a)}}\]
                    </div>
                    <p>
                        <br><span class="highlight" style="color: rgb(0, 3, 206);">즉 우리가 구하고싶은 log likelihood의 lower bound는 \(\sum_{s}{p(s|a)\log{p(y|s,a)}}\)가 되고 이를 loss function으로 사용합니다.
                        즉 저자는 lower bound의 log liklihood를 최대화하면 원래의 식도 같이 최대화 된다고 주장하고 있습니다.</span>
                        즉 최종적인 loss는 아래처럼 정의됩니다.
                    </p>
                    <div class="equation">
                        \[L_{s}=\sum_{s}{p(s|a)\log{p(y|s,a)}}\]
                    </div>
                    <p>
                        <br>따라서 위의 loss를 모델의 weight \(W\)에 대해 미분하게 되면 아래처럼 쓸 수 있습니다.
                    </p>
                    <div class="equation">
                        \[\frac{\partial L}{\partial W} = \sum_s \left[p(s|a)\frac{\partial \log{p(y|s,a)}}{\partial W} + \log p(y|s,a)\frac{\partial p(s|a)}{\partial W} \right]\]
                        \[= \sum_s \left[p(s|a)\frac{\partial \log{p(y|s,a)}}{\partial W} + \log p(y|s,a) \cdot p(s|a)\frac{\partial \log{p(s|a)}}{\partial W} \right]\,(\because f' = f \cdot (\log{f})') \]
                        \[= \sum_s p(s|a) \left[ \frac{\partial \log{p(y| s,a)}}{\partial W} + \log p(y|s,a)\frac{\partial \log{p(s|a)}}{\partial W} \right]\]
                    </div>
                    <p>
                        <br>하지만 위의 결과처럼 모든 s에 대해 경우의 수를 구해서 parameter를 업데이트 하는 방식은 오래걸리고 비효율적이기 때문에 Monte Carlo Estimation을 통해 충분히 많은 N개의 데이터를 추출하여 이들의 평균값을 이용합니다.
                        충분히 많은 N개의 데이터를 이용하여 전체의 데이터를 사용한 효과를 도모하는 것이 바로 Monte Carlo Estimation이고, <a onclick="pjaxPage('VAE1.html');"><span class="highlight" style="color: rgb(0, 3, 206);">VAE 글</span></a>에서도 언급한 바 있습니다.
                        따라서 위의 미분 값을 Monte Carlo Estimation을 적용하여 아래와 같이 다시 적을 수 있습니다.
                    </p>
                    <div class="equation">
                        \[\frac{\partial L}{\partial W} \approx \frac{1}{N} \sum_n^N \left[ \frac{\partial \log p(y| \tilde{s^n},a)}{\partial W} + \log p(y| \tilde{s^n},a)\frac{\partial \log{p(\tilde{s^n} |a)}}{\partial W} \right]\]
                        \[\tilde{s_t} \sim \mbox{Multinoulli}_L (\alpha)\]
                    </div>
                    <p>
                        <br>이때 \(\tilde{s_t}\)는 multinoulli distribution에서 N개를 sampling 한다는 뜻입니다.
                        하지만 Monte Carlo Estimation을 하게 되면 분산이 크게 나오는 문제점이 있습니다. 우리는 전체를 고려하는 것이 아니라 일부 데이터를 고려합니다.
                        따라서 매 추출마다 무작위로 서로 다른 영역에서 선택되면 분산이 커지는 것은 당연한 것입니다.
                        이를 방지하기 위해 저자는 아래와 같이 exponential moving average를 사용합니다.
                    </p>
                    <div class="equation">
                        \[b_k = 0.9\times b_{k-1} + 0.1\times\log p (y | \tilde s_k, a)\]
                    </div>
                    <p>
                        <br>위 식은 이전 정보를 90 %, 지금 정보를 10 %만 이용하여 업데이트 하겠다는 뜻입니다.
                        또한 분산이 커지는 것을 막기 위해 entropy term \(H\)도 추가로 넣어주고나서 최종 loss는 아래와 같이 표현할 수 있습니다.
                    </p>
                    <div class="equation">
                        \[\frac{\partial L}{\partial W} \approx \frac{1}{N} \sum_n^N \left[ \frac{\partial \log p(y|\tilde{s^n},a)}{\partial W} + \lambda_r \big( \log{p(y|\tilde{s^n}, a)} - b \big) \frac{\partial \log{p(\tilde{s^n} |a)}}{\partial W} + \lambda_e \frac{H[\partial \tilde{s^n}]}{\partial W} \right]\]
                    </div>
                    <p>
                        <br>위 식에서 \(\lambda_r, \lambda_e\)는 각각 exponential moving average와 entropy term의 적용 비율을 나타내는 파라미터가 됩니다.
                        뿐만 아니라 분산을 줄이기 위해 주어진 이미지에 0.5의 확률로 s̃의 값을 s̃ 대신 \(\alpha\)로 넣기도 합니다.
                        <span class="highlight" style="color: rgb(0, 3, 206);">그리고 이렇게 구한 최종 loss 식은 강화학습과 비슷합니다. 왜냐하면 1이 될 위치를 고르는 action에 따라 \(L_{s}\)라는 reward를 받게 되는 방식인 것이지요.</span>                    
                        본 논문에서는 이 두 방식을 사용하여 나온 attention의 결과를 비교합니다.
                        아래 이미지 중 위의 결과가 soft attention의 결과이고, 아래의 결과가 hard attention의 결과입니다.
                    </p>
                    <div class="contentImg">
                        <img src="https://lh3.googleusercontent.com/fife/AMPSemdFRHl0N3N4YA93I0ae5QXEzv6RON_3Ul8N8dUX2vmpWxtuRepI6PzJeIij52RYHklp5e4JvBkAgz6X1RR3O3XTf_HgZZF-N5jLW5KSs7wP5qeRFnx5UWbk1E2wW3zpsIQxu5usZzKD751FoACx16CYZQxIOLB19ZCNs2nL59Pb7idiL-GfnASkd2yzZPv-vFI6r7trq6U1R3Ek1bsCI5totSMUGUdWaqieIimBqHIx4Y6nZhM69lJ0GAWH39XSwURVuT6OQBn17lwNjgNe6nOo5AcM7znfbfrEGe-u44EzMq36R4bFErXSTcRDEtxdb_7fBErOzGffUMmwTAqvHl_7DNp_h0AZuF6P7HWCo-_MAJvPptFXG9av9Flf-jvxot11SkmVXei1KitzF4l7tmn5fK6wEzegI7ijnlpxUq3THs6P-2JxROeX0_PnzmBtZ4oza21geuEqaBv1Gz2ch126N0ZIze9PKU-jmMLIlDLYip23pv_63cVCie2brSHp-OYniOzqvpW4VBRPVpA8JHtBhn5LhlAB8unuDRoUoZyVdB4My-fY9cHg-YA7SJRIc_ssJGBvCRwq8DjowVGLUja0c9qVR-msmQBT_tIL-9cIAy2dW_TSi1ZJGRNg3rIaWufNPUQrApxNN5yMEEPLyeYFsb9ULvkEIeDuBefJDC6fq2yxQSlPBhMEQpwwezraE7Cu5mNmpiVtvAuKNwl53MDtsvFwqLgo4AWhhvPjYj1XCsgChkB2ZbIzu1OxpOC_cxK9eSsRnnZfTrzQ1DS-UAQckRiQ2AXO6H-Js-FYWF_30_dMJtEyE59fVK8xOY3c6gJ5flybjUQOwk0D_ZOekJabcC7ywBBLJ8NIq3RCmAP40o6OBaur0bI0EZmBzwyCThSGrFtANRgN3BHqwo_wiuMSmroXt9_AwS9ketnSPWWJvNqogb2hUd5WAbiyJSIShTVaDfdKfZBZ7L1ARb_bcwxm4oLfNKkExOt7kl43lNc25UnIBlKCPGxi4bL4hqFMIWPLM5U1QaUU-0dUqRnW7oKM7wisLYpfjw4b_noyEyaA4xMQsnyhWXOV5hgwie7c11_a1MGuFNyGkN-ccvAlA1FSRo35rfvOeO_6GvgJdfDCKauQw7LAnNUc2mrMelYMcL3KuNZeisUXEpHokJbDK2EU_wd19otJsC6_tC9kfnLpG_YtjsCjkkDNMetJGw8kNPbrqxOAYaXljC6KxhWo5OhyE_fP5B_sxvGdIazG5tbP749816YdvZZh4WslF99-SWlXhlbnl86sEQ_pLdeupL6M1nFNdQuDHke8Lh0bUc6Q2EGnRV--I4KiUoliLL_od43hfh9UNCNXWfRddthDbT6nLBWoympQJk6-ywyWKWLQ2fV4AiZ7L9RU30IWT99UOf1Xk5Ms8x0mzNju3eDSCZ7YONNB-Hu7rYbL6_EsKIFbZ3WlOaw0SDC59MEvUe1E-SWB8IxuW25KxvT8WwwFbg4" style="width: 100%;">
                        <p class="caption">Soft, hard attention 결과, 출처: Show, Attend and Tell 논문</p>
                    </div>
                    <p>
                        <br>논문에서는 캡션 생성 모델 성능 평가를 위해 BLEU, METEOR 지표를 사용했습니다.
                        COCO, Flickr8k, Flickr30k 데이터에 대해 실험을 진행한 결과 hard attention을 사용했을 때가 soft attention을 사용했을 때보다 더 결과가 좋았다고 합니다.
                    </p>
                    <div class="contentImg">
                        <img src="https://lh3.googleusercontent.com/fife/AMPSemcnn-xu46qXP3B3_FV7L4YFqm6f8SMW6DgTlq5duFQHtRgliaGEQTTr1x7AeocrD3_nQiv2o_vMuDP2BLKry9WdQVjA5fu3JNNdKvgleoxz6Rr0MVDUEk2K0FnHVBrWBfsSbuXx0GAWvn9QMksdDAMazjFRdxqqAIWLc0u9ZJuaEpAMo_bg7jahxBalvWe8lfVS4dt4iRlOikq-yxz3OVULEk6xrS5i9qlBclU5eAXvL_7EhF4bITYpOKbKFgf9d5hqBRitw6VsQ5nmG9Vf9yHjmCyynhzVYowuyvx2flhfasi3gLzA5CRlqLmAcTkTgKLVhz-p5ZKJb8CaKy66WtIX0NvvKHWNpz4XwLr4XQ5pluNQwyhBOSJKdAC_v1gsNUyAX87oWS9fXwgIe-6Oc0jbeUYe-eYtWUhxvR82Z_ZIXJvD6VfjUo-Rm_poOetkSNzSWV8hwlSdRcg1910VyDrKYa7k5a5Gx3ckULhZ5B4wH9kZCkTK_2QrDJUk_v0JMCztrU0yDP1cahLr7Jg-T6aT1UxaokosLzQ_XfxDcQi5uRLm4ptXJltTFS9tgiGNdJcyu6YGJmCNeptJQedTh2RclPjmQLgXbQn-iEo77BjfGQC1EpBdX2IE4L-Zvubx0cGsnxb66APzfkbq7otbjrsr93Y91iyUtAWc46UiOd2AW6Vl0xBxaIfozOe-H4MMlBIRQU8ZF_upJIAau3R_PWqjiUIK6kmN8SxalTA5p0pBO3YneuYcQzsCUetsbT_E1ZsXThKtguuyjO3GJR9AHoTuc9Tje0q-3tl_KUUN4e4PTiF_Mr6bHU28hzsjExJkn3pTmwQLDjK8Q-mo7xxALUPCBfAbQMytlneuid8R7N2bxFV96F7_T35PyDQujanJ1pJxKtO6qfZKf3b4wjMa-XWmctaNiuvUX5qzh3j8nxaC52XWhOMYH1fYyy5jXUo15Tp5pi_NwdJFYLFoiWN-76aPE75EIJ8OdiMaGcHsgYJVtFNp1wLjvwOvoiR5D60OBtf_-LjOKwgW97Hs8fO-j2HOtmFHku7wvdNxRJB9UFsPRWxzsi8GS2O0Q1IZHJESS0y2zwpO16_QGZxBsucG0ICkd77WSLrjDp_pP8LOOUwD1DR-nvZo1E48AfBmVfAEW3o6xQiBOWZzLk6MYWjvHSrnmW9BpHDigUO6rZNvrdy8Lv-O_b7MENxL18gebVZEn6fmdHec600lFPiGPB0rlQdiwf30LAvObhSUoFgYpjc-sKGGI-BqbtjW8XtRWWkH3XGAS1eWNX7uV4Y-E3WSzDKeAI0gZAYannEdkFGZXGtD__i2PHV-O-6VFmoGxpoXR1BdpVVj-H0WFSy5d9E2yeJQtMfH5Saf-vhDnGqw1lROJMRr-TSrloM8C_-XFVckHEiYou3bNkTJ9g_rCbotxB28swAPKloNfOH53DTKuwuQJIgUT3lVGF1Hv9SD2-rFjDycSto2M4QC-xypfUOTqxQ" style="width: 100%;">
                        <p class="caption">모델 결과, 출처: Show, Attend and Tell 논문</p>
                    </div>

                    
                    <p>
                        <br><br><br>다음에는 Flickr8k 데이터를 바탕으로 Show, Attend and Tell 논문 구현을 해보도록 하겠습니다.
                    </p>


                    
                </div> 
                <div class="tag">
                    <b>태그</b>&emsp;#ImageCaptioning&emsp;#SoftAttention&emsp;#HardAttention
                </div>
                <div class="pageTurner">
                    <div class="pageTurnerLeft">
                        <span><a style="position: absolute; left: 0;" onclick="alert('Image Captioning 첫 게시물 입니다.\n\nThis is the first post of Image Captioning.')" onmouseover="colorOn(this);" onmouseout="colorOff(this);">&lang; 이전글</a>
                        <br></span>
                    </div>
                    <div class="pageTurnerRight">
                        <span><a style="position: absolute; right: 0;" onclick="pjaxPage('img2txt2.html');" onmouseover="colorOn(this);" onmouseout="colorOff(this);">다음글 &rang;</a>
                        <br>ResNet, LSTM을 이용한 Flickr8k 이미지 캡션 생성</span>
                    </div>
                </div>
                <span id="readNum"></span>
                <div id="disqus_thread"></div>

                <script>
                    headHighlightColorChanger();
                    (function() { // DON'T EDIT BELOW THIS LINE
                    var d = document, s = d.createElement('script');
                    s.src = 'https://novicetraveler.disqus.com/embed.js';
                    s.setAttribute('data-timestamp', +new Date());
                    (d.head || d.body).appendChild(s);
                    })(); 
                </script>
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            </article>
        </div>

        <div id="menuRelated">
            <div class="menuButton">
                <img id="menuImg" src="init/index_img/menu_black.png" onclick="openMenu(this);">
            </div>
            <div class="menu">
                <img id="menuExtension" title="메뉴를 확장합니다." src="init/index_img/extension_black.png" onclick="extendMenu(this);">
                <div class="profile">
                </div>
                <ul class="tree">
                </ul>
                <p class="copyrights">
                    © 2022. 여행 초짜. All rights reserved.
                </p>
            </div>
            <div class="bigMenu">
                <img id="menuCompression" title="메뉴를 축소합니다." src="init/index_img/compression_black.png" onclick="compressMenu(this);">
                <div class="profile">
                </div>
                <ul class="tree">
                </ul>
                <p class="copyrights">
                    © 2022. 여행 초짜. All rights reserved.
                </p>
            </div>
        </div>

        <script>
            detectScroll();
            pushFunc();
            detectSize();
        </script>
    </body>
</html>